
#include "neslib.h"

const unsigned char level_data[] = {
	// Screen 1
	0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 0
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 1
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 2
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 3
	0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 4
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 5
	0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 6
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 7
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 8
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 9
	0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 10
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 11
	0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 12
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 13
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 14
	0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 15

	// Screen 2
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 0
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 1
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 2
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 3
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 4
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 5
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 6
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 7
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 8
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 9
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 10
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 11
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 12
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 13
	0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 14
	0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, // <-- column 15

};

static unsigned char update_list[3+32+3+8+1];//3 bytes address and length for 32 tiles, 3 bytes address and length for 8 attributes, end marker

const unsigned char palette[16]={ 0x0f,0x16,0x26,0x36,0x0f,0x18,0x28,0x38,0x0f,0x19,0x29,0x39,0x0f,0x1c,0x2c,0x3c };

//metatile palettes

#define BGPAL0	0x00	//bin 00000000
#define BGPAL1	0x55	//bin 01010101
#define BGPAL2	0xaa	//bin 10101010
#define BGPAL3	0xff	//bin 11111111

//metatile definitions, one metatmetatilesile by another, 4 bytes per metatile

#if 0
const unsigned char metatiles[]={
	0x00,0x00,0x00,0x00,
	0x80,0x81,0x90,0x91,
	0x82,0x83,0x92,0x93,
	0x84,0x85,0x94,0x95,
	0x86,0x87,0x96,0x97
};
#else
const unsigned char metatiles[]={
	0x00,0x00,0x00,0x00,
	0x80,0x81,0x90,0x91, // 0x80 = UL, 0x81 = UR 0x90 = LL, 0X91 = LR
	0x82,0x83,0x92,0x93,
	0x84,0x85,0x94,0x95,
	0x86,0x87,0x96,0x97
};
#endif

//metatile attributes, define which palette should be used for a metatile

const unsigned char metaattrs[]={
	BGPAL0,
	BGPAL0,
	BGPAL1,
	BGPAL2,
	BGPAL3
};
void main(void)
{
	static unsigned char col,i,current_metatile;
	static unsigned int name_adr,attr_adr;
	static unsigned char write_offset,read_offset, metatile_offset;
	//rendering is disabled at the startup, and palette is all black
	
	pal_bg(palette);//set background palette from an array

	update_list[0]=0x20|NT_UPD_HORZ;//horizontal update sequence, dummy address
	update_list[1]=0x00;
	update_list[2]=32;//length of nametable update sequence

	#if 0
	update_list[35]=0x20|NT_UPD_HORZ;
	update_list[36]=0x00;metatiles
	#else
	update_list[35]=NT_UPD_EOF;
	#endif

	// Fill our screen from level data, one column at a time, left to right
	// We do it one colum at a time because each column uses the entire update_list
	// Doing it one colum at a time also is more amenable to side scrolling where
	// we just have to keep updating a sinle column at a time as the player moves right.
	for(col = 0; col < 32; ++col)
	{
		metatile_offset = col & 0x1;	
		//vram_adr(NAMETABLE_A);//set VRAM address

		// Put together a vram update list to update a single column
		// It will be in the form:
		// MSB|NT_UPD_VERT, LSB, LEN, [bytes] for a vertical sequence
		
		//name_adr=NAMETABLE_A+(name_row<<5);
		//attr_adr=NAMETABLE_A+960+((name_row>>2)<<3);
		name_adr=NAMETABLE_A+(col);
		#if 0
		attr_adr=NAMETABLE_A+960+((col>>2)<<1);
		#endif

		update_list[0] = MSB(name_adr)|NT_UPD_VERT;//set nametable update address
		update_list[1] = LSB(name_adr);
		update_list[2] = 32; // writing 32 tiles in column

		// 16 metatiles per column, writing 2 per metatile
		write_offset = 3;
		read_offset = 0;
		for(i=0; i<16; ++i)
		{
			#if 0
			update_list[write_offset] = 0x80;//level_data[write_offset];
			++write_offset;
			update_list[write_offset] = 0x80;//level_data[write_offset];
			++write_offset;
			#else
			current_metatile = level_data[((col>>1)<<4) + read_offset];
			update_list[write_offset] = metatiles[4*current_metatile + metatile_offset];
			++write_offset;
			update_list[write_offset] = metatiles[4*current_metatile + metatile_offset + 2];
			++write_offset;
			if(write_offset & 0x1)
				++read_offset;
			#endif
		}
		update_list[35]=NT_UPD_EOF;

		#if 0
		update_list[35]=MSB(attr_adr)|NT_UPD_VERT;//set attribute table update address
		update_list[36]=LSB(attr_adr);
		#endif
		
		flush_vram_update(update_list);
	}
	//vram_unrle(test_nam);//unpack nametable into VRAM

	ppu_on_all();//enable rendering

	while(1);//do nothing, infinite loop
}
